New notes/issues/activities:
* We need to review the logic of CopyPageMetadata of BasePageTransformator when writing fields values to the target
	* Do we have full feature coverage in PnP Core? Yes, we do
* Do we still need to support blog pages? Aren't them deprecated?
	* yes
* Where do we set SetAuthorInPageHeader in the current model? I can't find it ...
	* Bert will double-check
- We need to debug issues with images and "real" web parts like List modern web part
* Is the content type handling correct? Shouldn't we just get the new one of the "modern page"?
	* We need to dig into this, there are cases where we need it for publishing pages
	- Add yet another mapper for content type IDs used where we work with page layout mappings
* We need to have an "open" model for storing binary assets (by default on the file system)
	* Define a mapping model for assets with yet another mapping provider
	* Make it possible to optimize bandwidth skipping already existing files on the target
	* The default mapper will simply read and write the file taking care of duplicates
	* In MappingOutput store both file ID and hash of content
* Implement SummaryLinksToQuickLinksProperties function in SharePointFunctionService.cs
	- Mind the fact that current implementation in PnP Framework relies on both source and dest page/context
* Implement ReturnCrossSiteRelativePath function in SharePointFunctionService.cs
	- Mind the fact that current implementation in PnP Framework relies on both source and dest page/context
* Publish news at the end of transformation
* Reset system properties like file created, modified, created by, modified by, etc.

Closed questions:
* I installed Newtonsoft.Json because I don't want to go crazy :-) with web part properties ...
	* ok so far
* User transformation: do we really want to search on the on-premises AD domain via LDAP?
	* Ok to focus on essentials right now
* Can we change the "model" for custom AddOns relying on dependency injection rather than on reflection?
	* low priority, so far
* I need to better understand the logic around PageFolder from line 345 to 432 in PageTransformator.cs
	* I need to better understand Root/ for isRootPage (PageTransformator line 399)
* We cannot rely on PnP Provisioning Template for fields, we can't have a dependency on PnP Framework
	* Ok we agreed on a solution => manually generated class file with field names to exclude, so far
* Are we sure that the built-in fields of PnP Core are correct?
	* Should we exclude built-in fields on the source side?

Architectural notes:
* implement all the native providers with file-based approach (both XML and JSON)
* add With* methods to the builder
	* builder.WithName("MyConfiguration).WithWebPartMappingProvider<MyCustomWebPartMappingProvider>().With*().Build();
* or what about having also named options?
	- https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-5.0#named-options-support-using-iconfigurenamedoptions
* abstract the "executor" of a transformation request
* implement PageTransformator through interface IPageTransformator
* all asynchronous
* add support for external executor
	* provide default in-memory executor
- implement a Metadata Mapping provider with support for an in-memory dictionary of fields to add to the target
- add support for "delta" transformation
	- transform only pages updated after XYZ (stored somewhere, like in the property bag of the Pages library or of the site)
- think about having a LayoutTransformator and ContentTransformator abstraction

* Hierarchy:
	TransformationDistiller <- TransformationExecutor -> PageTransformator
										|
										˅
								TransformationStateManager

* TransformationDistiller: defines the list of items (pages) to process
* TransformationExecutor:
	- Creates/Loads a TransformationProcess
		- Start/Stop
		- Events to notify status
		- GetStatus
	- Flavors:
		- Synchronous
		- Parallel
		- Background
		- External
* PageTransformator: does the actual tranformation of a single page
* TransformationStateManager: handles state management for the Executor

Things to think about:
- How do we pass configuration settings (like file path) to mapping provider instances in With* methods?
	- We need an "open" configuration model, because we don't simply need file path, but also other kind of settings (like db connection string, etc.)

Questions for Bert:
* What is the whole Observer thing? Can't we simply use logging?
	* Nowadays it generates a report of what happened ... think about that, talk with Paul Bullock -> Paul said that we can remove it
* Do we really need a "custom" cache?
	* Ok we can use the out of the box one
* What if we just implement one PageTransformator that adapts to the page instead of PageTransformator and PublishingPageTransformator?
	* Yes, we are on the same page
- Is TargetPageFolderOverridesDefaultFolder really needed? Can't we just rely on TargetPageFolder != null?
	- Pending ...
* Do we need SkipUrlRewrite and SkipDefaultUrlRewrite? Can't we just rely on IUrlMappingProvider specific implementation?
	* Ok
- I need to better understand the purpose of AddTableListImageAsImageWebPart
	- Future meeting
- About the MappingProperties property, can we simply rely on the Metadata Mapping provider?
	- Future meeting
* Do we still need PageTitleOverride, LayoutTransformatorOverride, and ContentTransformatorOverride?
	* Can't we rely on the new providers model?
		* Ok, except ContentTransformatorOverride
- What's the purpose of the "internal fields"? (Folder, IsCrossFarmTransformation, etc.)
	- Future meeting
* Is the ModernizationCenter gone, right?
	* Yes
* Do we really need TargetPageTakesSourcePageName? Can't we simply rely on TargetPageName and if blank it will take source page name?
	* Ok
* PnPContext is online only. How do we manage on-prem sources in the new Modernization Framework based on PnP.Core?
	* Refactoring coming to ensure support for on-prem and other sources ...

Bert's feedback:
* HTML Content Mapping Provider
* Custom mapping provider pre/post-transformation with order
* Don't assume that the source is always Microsoft SharePoint
	* Add another level of abstraction for generic data sources
	* We cannot use PnPContext for SourceContext, we need to support on-prem and other sources
	* Source:
		* Metadata (dictionary)
		* RawContent (string -> GetStreamAsync)
		* Components/Parts (IEnumerable<{ id, Properties: Dictionary, GetStreamAsync }>)
		* Users
			* CreatedBy
			* ModifiedBy
		* Taxonomy
* PnP.Core.Modernization => PnP.Core.Transformation
* Internal multiple transformators, outside just one
- JSON configuration file for PowerShell
- PnP Core pre-requirements to check


TODO:
- Replace all explicit strings with resource strings
- state or status?
- Consider creating custom Exception types
- Unified logging utility, to log data with TransformationId, Source/Target coordinates, etc.
