Architectural notes:
- implement all the native providers with file-based approach (both XML and JSON)
- add With* methods to the builder
	- builder.WithName("MyConfiguration).WithWebPartMappingProvider<MyCustomWebPartMappingProvider>().With*().Build();
- or what about having also named options?
	- https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-5.0#named-options-support-using-iconfigurenamedoptions
- abstract the "executor" of a transformation request
- implement PageTransformator through interface IPageTransformator
- all asynchronous
- add support for external executor
	- provide default in-memory executor
- implement a Metadata Mapping provider with support for an in-memory dictionary of fields to add to the target
- add support for "delta" transformation
	- transform only pages updated after XYZ (stored somewhere, like in the property bag of the Pages library or of the site)
- think about having a LayoutTransformator and ContentTransformator abstraction

- Hierarchy:
	TransformationDistiller <- TransformationExecutor -> PageTransformator
										|
										˅
								TransformationStateManager

- TransformationDistiller: defines the list of items (pages) to process
- TransformationExecutor:
	- Creates/Loads a TransformationProcess
		- Start/Stop
		- Events to notify status
		- GetStatus
	- Flavors:
		- Synchronous
		- Parallel
		- Background
		- External
- PageTransformator: does the actual tranformation of a single page
- TransformationStateManager: handles state management for the Executor

Things to think about:
- How do we pass configuration settings (like file path) to mapping provider instances in With* methods?
	- We need an "open" configuration model, because we don't simply need file path, but also other kind of settings (like db connection string, etc.)

Questions for Bert:
- What is the whole Observer thing? Can't we simply use logging?
- Do we really need a "custom" cache?
- What if we just implement one PageTransformator that adapts to the page instead of PageTransformator and PublishingPageTransformator?
- Is TargetPageFolderOverridesDefaultFolder really needed? Can't we just rely on TargetPageFolder != null?
- Do we need SkipUrlRewrite and SkipDefaultUrlRewrite? Can't we just rely on IUrlMappingProvider specific implementation?
- I need to better understand the purpose of AddTableListImageAsImageWebPart
- About the MappingProperties property, can we simply rely on the Metadata Mapping provider?
- Do we still need PageTitleOverride, LayoutTransformatorOverride, and ContentTransformatorOverride?
	- Can't we rely on the new providers model?
- What's the purpose of the "internal fields"? (Folder, IsCrossFarmTransformation, etc.)
- Is the ModernizationCenter gone, right?
- Do we really neew TargetPageTakesSourcePageName? Can't we simply rely on TargetPageName and if blank it will take source page name?
- PnPContext is online only. How do we manage on-prem sources in the new Modernization Framework based on PnP.Core?
